"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _react = _interopRequireWildcard(require("react"));
var _reactDock = require("react-dock");
var _actions = require("./actions");
var _reducers = _interopRequireDefault(require("./reducers"));
var _parseKey = _interopRequireDefault(require("parse-key"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
class DockMonitor extends _react.Component {
  static update = _reducers.default;
  static defaultProps = {
    defaultIsVisible: true,
    defaultPosition: 'right',
    defaultSize: 0.3,
    fluid: true
  };
  constructor(props) {
    super(props);
    const childrenCount = _react.Children.count(props.children);
    if (childrenCount === 0) {
      // eslint-disable-next-line no-console
      console.error('<DockMonitor> requires at least one monitor inside. ' + 'Why donâ€™t you try <LogMonitor>? You can get it at ' + 'https://github.com/reduxjs/redux-devtools/tree/master/packages/redux-devtools-log-monitor.');
    } else if (childrenCount > 1 && !props.changeMonitorKey) {
      // eslint-disable-next-line no-console
      console.error('You specified multiple monitors inside <DockMonitor> ' + 'but did not provide `changeMonitorKey` prop to change them. ' + 'Try specifying <DockMonitor changeMonitorKey="ctrl-m" /> ' + 'and then press Ctrl-M.');
    }
  }
  componentDidMount() {
    window.addEventListener('keydown', this.handleKeyDown);
  }
  componentWillUnmount() {
    window.removeEventListener('keydown', this.handleKeyDown);
  }
  matchesKey(key, event) {
    if (!key) {
      return false;
    }
    const charCode = event.keyCode || event.which;
    const char = String.fromCharCode(charCode);
    return key.name.toUpperCase() === char.toUpperCase() && key.alt === event.altKey && key.ctrl === event.ctrlKey && key.meta === event.metaKey && key.shift === event.shiftKey;
  }
  handleKeyDown = e => {
    // Ignore regular keys when focused on a field
    // and no modifiers are active.
    if (!e.ctrlKey && !e.metaKey && !e.altKey && (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable)) {
      return;
    }
    const visibilityKey = (0, _parseKey.default)(this.props.toggleVisibilityKey);
    const positionKey = (0, _parseKey.default)(this.props.changePositionKey);
    let monitorKey;
    if (this.props.changeMonitorKey) {
      monitorKey = (0, _parseKey.default)(this.props.changeMonitorKey);
    }
    if (this.matchesKey(visibilityKey, e)) {
      e.preventDefault();
      this.props.dispatch((0, _actions.toggleVisibility)());
    } else if (this.matchesKey(positionKey, e)) {
      e.preventDefault();
      this.props.dispatch((0, _actions.changePosition)());
    } else if (this.matchesKey(monitorKey, e)) {
      e.preventDefault();
      this.props.dispatch((0, _actions.changeMonitor)());
    }
  };
  handleSizeChange = requestedSize => {
    this.props.dispatch((0, _actions.changeSize)(requestedSize));
  };
  renderChild(child, index, otherProps) {
    const {
      monitorState
    } = this.props;
    const {
      childMonitorIndex,
      childMonitorStates
    } = monitorState;
    if (index !== childMonitorIndex) {
      return null;
    }
    return /*#__PURE__*/(0, _react.cloneElement)(child, {
      monitorState: childMonitorStates[index],
      ...otherProps
    });
  }
  render() {
    const {
      monitorState,
      children,
      fluid,
      ...rest
    } = this.props;
    const {
      position,
      isVisible,
      size
    } = monitorState;
    return /*#__PURE__*/_react.default.createElement(_reactDock.Dock, {
      position: position,
      isVisible: isVisible,
      size: size,
      fluid: fluid,
      onSizeChange: this.handleSizeChange,
      dimMode: "none"
    }, _react.Children.map(children, (child, index) => this.renderChild(child, index, rest)));
  }
}
var _default = exports.default = DockMonitor;